# Gu√≠a de ArchUnit - Reglas Arquitect√≥nicas Espec√≠ficas

## ¬øQu√© es ArchUnit?

ArchUnit es una biblioteca de testing para Java que permite definir y verificar reglas arquitect√≥nicas mediante pruebas automatizadas. Esto ayuda a mantener la arquitectura limpia y consistente a lo largo del tiempo.

## Configuraci√≥n Implementada

### Dependencia Agregada
```xml
<dependency>
    <groupId>com.tngtech.archunit</groupId>
    <artifactId>archunit-junit5</artifactId>
    <version>1.2.1</version>
    <scope>test</scope>
</dependency>
```

## Clases de Prueba Creadas Seg√∫n Especificaciones

### 1. UbicationTest.java
**Prop√≥sito**: Verificar estructura de carpetas y ubicaci√≥n correcta

**Reglas implementadas**:
- Controllers solo en `controller.rest`
- UseCases solo en `application.service`
- DTOs solo en `application.dto`
- Repositorios (interfaces) en `domain.repository`
- Implementaciones de repositorios en `infrastructure.persistence`
- Entidades JPA (@Entity) en `infrastructure.persistence`
- Entidades de dominio en `domain.model`
- ValueObjects en `domain.model.valueobject`
- Adaptadores externos en `infrastructure.external`
- Configuraciones en `configuration`

### 2. AccesTest.java
**Prop√≥sito**: Verificar normas de acceso entre capas

**Reglas implementadas**:
- Controllers solo pueden acceder a `application`
- `application.service` solo puede acceder a `domain` y `application.dto`
- `domain` NO puede acceder a ninguna otra capa
- `infrastructure` puede acceder a `domain.repository` pero nunca a controller ni application
- DTOs no pueden depender de clases fuera de application
- Adaptadores no deben acceder directamente a `domain.model`

### 3. DependencyTest.java
**Prop√≥sito**: Verificar normas de dependencias y prevenir ciclos

**Reglas implementadas**:
- No ciclos entre paquetes
- Solo `infrastructure.persistence` puede usar @Entity o JpaRepository
- Solo `controller.rest` puede usar @RestController
- Solo `application.service` puede usar @Service
- Solo `infrastructure.persistence` puede usar @Repository
- Domain no puede importar Spring Framework
- Domain no puede tener anotaciones de Spring

### 4. NameTest.java
**Prop√≥sito**: Verificar convenciones de nomenclatura

**Reglas implementadas**:
- Controllers terminan en "Controller"
- Use cases terminan en "UseCase"
- Entidades de dominio terminan en "Entity" o "Aggregate"
- Interfaces de repositorio empiezan por "I" o terminan en "Repository"
- DTOs terminan en "Dto"
- Value Objects terminan en "Value" o "VO"
- Mappers terminan en "Mapper"
- Configuraciones terminan en "Config" o "Configuration"

### 5. AcopplementTest.java
**Prop√≥sito**: Verificar normas contra acoplamiento

**Reglas implementadas**:
- Domain no puede importar Spring
- Domain no puede tener anotaciones de Spring
- Domain entities solo lanzan excepciones del dominio
- UseCases no dependen de clases HTTP
- Solo Controllers pueden devolver clases HTTP
- No inyecci√≥n por campo (@Autowired)
- Domain no accede a infrastructure directamente
- Application no accede a infrastructure directamente

### 6. GoodPracticeTest.java
**Prop√≥sito**: Verificar buenas pr√°cticas generales

**Reglas implementadas**:
- Value Objects son inmutables
- No excepciones gen√©ricas
- No java.util.logging
- Use Cases son servicios (@Service)
- Entidades no dependen de persistencia
- Validaci√≥n en capas correctas
- Controllers no contienen l√≥gica de negocio

### 7. SolidTest.java
**Prop√≥sito**: Verificar principios SOLID

**Reglas implementadas**:
- SRP: Controllers solo coordinan
- OCP: Use cases no contienen l√≥gica de persistencia
- LSP: Entidades no acceden a bases de datos
- ISP: Use cases dependen de interfaces
- DIP: Infrastructure implementa abstracciones de domain
- Domain no depende de implementaciones concretas
- Application depende solo de interfaces

### 8. CleanCodeTest.java
**Prop√≥sito**: Verificar reglas de Clean Code

**Reglas implementadas**:
- Nombres expresivos (no Temp, Utils, Helper)
- Sin abreviaciones (no Ctrl, Svc, Res, Usr)
- No excepciones gen√©ricas
- No java.util.logging
- Controllers sin l√≥gica de negocio
- Validaci√≥n en capa correcta
- No System.out.println
- Inyecci√≥n por constructor preferida
- Paquetes con nombres significativos

### 9. JMoleculesTest.java üÜï
**Prop√≥sito**: Verificar uso correcto de anotaciones jMolecules DDD

**Reglas implementadas**:
- **@Entity** obligatorio en entities del domain
- **@AggregateRoot** obligatorio en aggregates del domain
- **@ValueObject** obligatorio en value objects
- **@Repository** obligatorio en interfaces de repositorio
- **@Service** obligatorio en domain services
- **@DomainEvent** obligatorio en eventos de dominio
- **@Factory** obligatorio en factories
- **@Identity** obligatorio en identificadores
- **NO uso** de anotaciones jMolecules fuera del domain
- **Implementaci√≥n** de interfaces jMolecules cuando corresponde

## C√≥mo Ejecutar las Pruebas

### Opci√≥n 1: Script Automatizado
```bash
./run-architecture-tests.bat
```

### Opci√≥n 2: Maven Directo
```bash
# Todas las pruebas de arquitectura
mvn test -Dtest="odoonto.architecture.*"

# Solo pruebas espec√≠ficas
mvn test -Dtest="odoonto.architecture.UbicationTest"
mvn test -Dtest="odoonto.architecture.AccesTest"
mvn test -Dtest="odoonto.architecture.DependencyTest"
mvn test -Dtest="odoonto.architecture.NameTest"
mvn test -Dtest="odoonto.architecture.AcopplementTest"
mvn test -Dtest="odoonto.architecture.GoodPracticeTest"
mvn test -Dtest="odoonto.architecture.SolidTest"
mvn test -Dtest="odoonto.architecture.CleanCodeTest"
mvn test -Dtest="odoonto.architecture.JMoleculesTest"
```

### Opci√≥n 3: Desde el IDE
Ejecuta las clases de test como cualquier prueba JUnit 5.

## Interpretaci√≥n de Resultados

### ‚úÖ Prueba Exitosa
```
[INFO] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0
```
Todas las reglas arquitect√≥nicas se cumplen.

### ‚ùå Prueba Fallida
```
Architecture Violation [Priority: MEDIUM] - Rule 'classes that reside in a package '..domain..' should not depend on classes that reside in any package ['..infrastructure..', '..presentation..', '..application..']' was violated (2 times):
Class <odoonto.domain.model.Patient> depends on class <odoonto.infrastructure.repository.PatientRepository> in (Patient.java:0)
```

**Interpretaci√≥n**: La clase `Patient` en el dominio est√° dependiendo de una clase de infraestructura, violando la regla de independencia del dominio.

## Beneficios de ArchUnit

1. **Prevenci√≥n autom√°tica**: Detecta violaciones arquitect√≥nicas antes de que lleguen a producci√≥n
2. **Documentaci√≥n viva**: Las reglas sirven como documentaci√≥n de la arquitectura
3. **Refactoring seguro**: Te avisa si cambios rompen la arquitectura
4. **Onboarding**: Ayuda a nuevos desarrolladores a entender las reglas
5. **Integraci√≥n CI/CD**: Se ejecuta autom√°ticamente en el pipeline

## Personalizaci√≥n

Para agregar nuevas reglas, edita las clases de test y agrega m√©todos con la anotaci√≥n `@ArchTest`:

```java
@ArchTest
static final ArchRule my_custom_rule = 
        classes()
            .that().resideInAPackage("..domain..")
            .should().notDependOnClassesThat()
            .resideInAPackage("..external..");
```

## Resoluci√≥n de Problemas Comunes

### Falsos Positivos
Si una regla est√° fallando por un caso leg√≠timo, puedes:
1. Modificar la regla para ser m√°s espec√≠fica
2. Agregar excepciones usando `.ignoreDependency()`
3. Comentar temporalmente la regla y crear un ticket para revisarla

### Rendimiento
Si las pruebas son lentas:
1. Usa `ImportOption.DoNotIncludeTests.class` para excluir clases de test
2. Limita el escaneo a paquetes espec√≠ficos
3. Ejecuta pruebas de arquitectura en un perfil separado

## Integraci√≥n con CI/CD

Agrega esto a tu pipeline para ejecutar autom√°ticamente:

```yaml
- name: Run Architecture Tests
  run: mvn test -Dtest="odoonto.architecture.*"
```

La integraci√≥n fallar√° si alguna regla arquitect√≥nica es violada, previniendo deployments con problemas arquitecturales.

## Resumen de Reglas Implementadas

### üìÅ Normas de estructura de carpetas (UbicationTest)
‚úÖ Controllers en `controller.rest`
‚úÖ UseCases en `application.service`  
‚úÖ DTOs en `application.dto`
‚úÖ Repositorios (interfaces) en `domain.repository`
‚úÖ Implementaciones en `infrastructure.persistence`
‚úÖ Entidades JPA en `infrastructure.persistence`
‚úÖ Entidades dominio en `domain.model`
‚úÖ ValueObjects en `domain.model.valueobject`
‚úÖ Adaptadores en `infrastructure.external`
‚úÖ Configuraciones en `configuration`

### üîê Normas de acceso entre capas (AccesTest)
‚úÖ Controllers ‚Üí solo application
‚úÖ application.service ‚Üí solo domain + application.dto
‚úÖ domain ‚Üí NO accede a ninguna otra capa
‚úÖ infrastructure ‚Üí domain.repository (NO controller/application)
‚úÖ DTOs ‚Üí NO dependen de nada fuera de application
‚úÖ Adaptadores ‚Üí NO acceso directo a domain.model

### üß© Normas de dependencias (DependencyTest)
‚úÖ Sin ciclos entre paquetes
‚úÖ @Entity solo en infrastructure.persistence
‚úÖ @RestController solo en controller.rest
‚úÖ @Service solo en application.service
‚úÖ @Repository solo en infrastructure.persistence

### üìõ Normas de nomenclatura (NameTest)
‚úÖ Controllers terminan en "Controller"
‚úÖ UseCases terminan en "UseCase"
‚úÖ Entidades terminan en "Entity/Aggregate"
‚úÖ Repositorios empiezan por "I" o terminan en "Repository"
‚úÖ DTOs terminan en "Dto"
‚úÖ ValueObjects terminan en "Value/VO"
‚úÖ Mappers terminan en "Mapper"

### üîå Normas contra acoplamiento + DDD Cr√≠ticas (AcopplementTest)
‚úÖ Domain sin dependencias Spring
‚úÖ Domain sin anotaciones Spring
‚úÖ UseCases sin clases HTTP
‚úÖ Solo Controllers devuelven ResponseEntity
‚úÖ Sin inyecci√≥n por campo (@Autowired)
‚úÖ **UseCases como boundaries transaccionales** (@Transactional)
‚úÖ **Value Objects inmutables** (campos final)
‚úÖ **Entities con identidad** (verificaci√≥n de estructura)
‚úÖ **Repositories solo Aggregates** (no entidades individuales)
‚úÖ **Command/Query Separation** (transaccional vs no-transaccional)
‚úÖ **Aggregates independientes** (no referencia directa entre aggregates)
‚úÖ **Domain Services puros** (sin dependencias de infrastructure)

### ‚ö° Principios SOLID (SolidTest)
‚úÖ SRP: Controllers solo coordinan
‚úÖ OCP: UseCases sin l√≥gica persistencia
‚úÖ LSP: Entidades sin acceso BD
‚úÖ ISP: UseCases dependen de interfaces
‚úÖ DIP: Infrastructure implementa abstracciones

### üßº Clean Code (CleanCodeTest)
‚úÖ Nombres expresivos (no Temp/Utils/Helper)
‚úÖ Sin abreviaciones (no Ctrl/Svc/Res/Usr)
‚úÖ Sin excepciones gen√©ricas
‚úÖ Sin System.out.println
‚úÖ Inyecci√≥n por constructor

## Estado Actual del Proyecto

Para verificar el cumplimiento actual de estas reglas en tu proyecto, ejecuta:

```bash
./run-architecture-tests.bat
```

Esto te mostrar√° qu√© reglas ya se cumplen y cu√°les necesitan ajustes en el c√≥digo actual.

## üéØ Reglas DDD Cr√≠ticas Implementadas

### üî• **NUEVAS REGLAS CR√çTICAS AGREGADAS**:

#### 1. **Agregados como Transaccional Boundaries**
```java
@Transactional  // ‚úÖ OBLIGATORIO en UseCases
public class CreatePatientUseCase {
    // Un UseCase = Una transacci√≥n = Un Aggregate modificado
}
```

#### 2. **Value Objects Completamente Inmutables**
```java
// ‚úÖ TODOS los campos deben ser final
public class PatientName {
    private final String firstName;  // ‚úÖ final
    private final String lastName;   // ‚úÖ final
    // + equals() y hashCode() override
}
```

#### 3. **Entities con Identidad Clara**
```java
// ‚úÖ Verificaci√≥n autom√°tica de estructura correcta
public class PatientEntity {
    private final PatientId id;  // ‚úÖ Campo de identidad requerido
}
```

#### 4. **Repositories Solo Trabajan con Aggregates**
```java
// ‚úÖ M√©todos solo retornan Aggregate roots
public interface PatientRepository {
    PatientAggregate findById(PatientId id);      // ‚úÖ Correcto
    // NO: PatientEntity findEntity(String id);   // ‚ùå Incorrecto
}
```

#### 5. **Command/Query Separation Estricto**
```java
// Commands (modifican estado)
@Transactional  // ‚úÖ OBLIGATORIO
public class CreatePatientCommandHandler { }

// Queries (solo leen)
// SIN @Transactional  // ‚úÖ OBLIGATORIO
public class GetPatientQueryHandler { }
```

#### 6. **Aggregates Completamente Independientes**
```java
public class PatientAggregate {
    // ‚úÖ Solo referencia ID de otros aggregates
    private AppointmentId appointmentId;  // ‚úÖ Solo ID
    
    // ‚ùå NO referencias directas
    // private AppointmentAggregate appointment;  // ‚ùå Prohibido
}
```

#### 7. **Domain Services Puros**
```java
// ‚úÖ Solo coordina aggregates del dominio
public class PatientDomainService {
    // SIN dependencias de infrastructure
    // Solo l√≥gica de dominio compleja que spans m√∫ltiples aggregates
}
```

### üìä **IMPACTO EN TU C√ìDIGO**:

Con estas reglas, tu c√≥digo **autom√°ticamente** seguir√°:
- ‚úÖ **Transactional Consistency** por aggregate
- ‚úÖ **Inmutabilidad** en Value Objects
- ‚úÖ **Boundaries claros** entre aggregates
- ‚úÖ **CQRS** pattern enforcement
- ‚úÖ **Domain purity** garantizada

### üîç **VERIFICACI√ìN AUTOM√ÅTICA**:

Cada vez que ejecutes:
```bash
./run-architecture-tests.bat
```

El sistema verificar√° que **TODAS** estas reglas DDD cr√≠ticas se cumplan en tu c√≥digo. Si alguna se viola, el build fallar√° con un mensaje claro explicando qu√© corregir.

**¬°Ahora tienes una implementaci√≥n DDD enterprise-grade garantizada por ArchUnit + jMolecules!** üéâ

## üÜï jMolecules Integration

### üìö **Documentaci√≥n DDD Autodocumentada**

Con jMolecules, tu c√≥digo DDD ahora se autodocumenta:

```java
@AggregateRoot  // ‚úÖ Expl√≠citamente un Aggregate Root
public class PatientAggregate {
    @Identity   // ‚úÖ Expl√≠citamente la identidad
    private final PatientId id;
}

@ValueObject    // ‚úÖ Expl√≠citamente un Value Object
public record PatientName(String firstName, String lastName) { }

@Repository     // ‚úÖ Expl√≠citamente un Repository del Domain
public interface PatientRepository { }
```

### üîç **Verificaci√≥n Autom√°tica Mejorada**

Las nuevas reglas de `JMoleculesTest` garantizan:
- ‚úÖ **Conceptos DDD expl√≠citos** con anotaciones jMolecules
- ‚úÖ **Separaci√≥n clara** entre domain y otras capas
- ‚úÖ **Integraci√≥n Spring autom√°tica** via jMolecules
- ‚úÖ **Documentaci√≥n viva** en el c√≥digo

### üìñ **Gu√≠a Completa de jMolecules**

Para ejemplos detallados y mejores pr√°cticas, consulta:
**[JMOLECULES_GUIDE.md](./JMOLECULES_GUIDE.md)**

**¬°Tu DDD ahora es completamente autodocumentado y autoverificado!** üöÄ 